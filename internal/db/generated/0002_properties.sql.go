// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 0002_properties.sql

package query

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProperty = `-- name: CreateProperty :one
insert into properties (
    agent_id, title, description, price, address, city, state,
    bedrooms, bathrooms, square_feet, property_type, 
    images, property_type, sale_type
) VALUES (
   $1, $2, $3, $4, $5, $6, $7,
   $8, $9, $10, $11,
   $12, $11, $13
) RETURNING id, property_type, status, sale_type, images, title, description, price, address, city, state, bedrooms, bathrooms, square_feet, agent_id, created_at
`

type CreatePropertyParams struct {
	AgentID      uuid.UUID            `json:"agent_id"`
	Title        string               `json:"title"`
	Description  pgtype.Text          `json:"description"`
	Price        pgtype.Numeric       `json:"price"`
	Address      string               `json:"address"`
	City         string               `json:"city"`
	State        string               `json:"state"`
	Bedrooms     pgtype.Int4          `json:"bedrooms"`
	Bathrooms    pgtype.Int4          `json:"bathrooms"`
	SquareFeet   pgtype.Int4          `json:"square_feet"`
	PropertyType PropertyType         `json:"property_type"`
	Images       []string             `json:"images"`
	SaleType     NullPropertySaleType `json:"sale_type"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.AgentID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Address,
		arg.City,
		arg.State,
		arg.Bedrooms,
		arg.Bathrooms,
		arg.SquareFeet,
		arg.PropertyType,
		arg.Images,
		arg.SaleType,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.PropertyType,
		&i.Status,
		&i.SaleType,
		&i.Images,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Address,
		&i.City,
		&i.State,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.SquareFeet,
		&i.AgentID,
		&i.CreatedAt,
	)
	return i, err
}

const getProperties = `-- name: GetProperties :many
select 
    id, property_type, images, title, description, price, 
    address, city, state, bedrooms, bathrooms, square_feet, created_at
from properties
where 
    ($1 = 'none' or title ilike '%' || $1 || '%')
    and ($2 = 'none' or city = $2)
    and ($3 = 'none' or state = $3)
    and ($4 = 0 or price >= $4)
    and ($5 = 0 or price <= $5)
    and ($6::text = 'none' or property_type::text = $6::text)
    and ($7::text = 'none' or sale_type::text = $7::text)
order by created_at desc
offset $8 limit 15
`

type GetPropertiesParams struct {
	Name         interface{} `json:"name"`
	City         interface{} `json:"city"`
	State        interface{} `json:"state"`
	MinPrice     interface{} `json:"min_price"`
	MaxPrice     interface{} `json:"max_price"`
	PropertyType string      `json:"property_type"`
	SaleType     string      `json:"sale_type"`
	Skip         int32       `json:"skip"`
}

type GetPropertiesRow struct {
	ID           uuid.UUID        `json:"id"`
	PropertyType PropertyType     `json:"property_type"`
	Images       []string         `json:"images"`
	Title        string           `json:"title"`
	Description  pgtype.Text      `json:"description"`
	Price        pgtype.Numeric   `json:"price"`
	Address      string           `json:"address"`
	City         string           `json:"city"`
	State        string           `json:"state"`
	Bedrooms     pgtype.Int4      `json:"bedrooms"`
	Bathrooms    pgtype.Int4      `json:"bathrooms"`
	SquareFeet   pgtype.Int4      `json:"square_feet"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetProperties(ctx context.Context, arg GetPropertiesParams) ([]GetPropertiesRow, error) {
	rows, err := q.db.Query(ctx, getProperties,
		arg.Name,
		arg.City,
		arg.State,
		arg.MinPrice,
		arg.MaxPrice,
		arg.PropertyType,
		arg.SaleType,
		arg.Skip,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertiesRow{}
	for rows.Next() {
		var i GetPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyType,
			&i.Images,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Address,
			&i.City,
			&i.State,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.SquareFeet,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyInfo = `-- name: GetPropertyInfo :one
select 
    p.id, p.property_type, p.images, p.title, p.description, p.price, 
    p.address, p.city, p.state, p.bedrooms, p.bathrooms, p.square_feet, p.created_at,
    json_build_object(
        'id', a.id,
        'picture', a.picture,
        'name', a.name,
        'description', a.description,
        'phone_number', a.phone_number,
        'email', a.email
    ) as agent
from properties p
inner join user_agents a on p.agent_id = a.id
where p.id = $1
`

type GetPropertyInfoRow struct {
	ID           uuid.UUID        `json:"id"`
	PropertyType PropertyType     `json:"property_type"`
	Images       []string         `json:"images"`
	Title        string           `json:"title"`
	Description  pgtype.Text      `json:"description"`
	Price        pgtype.Numeric   `json:"price"`
	Address      string           `json:"address"`
	City         string           `json:"city"`
	State        string           `json:"state"`
	Bedrooms     pgtype.Int4      `json:"bedrooms"`
	Bathrooms    pgtype.Int4      `json:"bathrooms"`
	SquareFeet   pgtype.Int4      `json:"square_feet"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Agent        json.RawMessage  `json:"agent"`
}

func (q *Queries) GetPropertyInfo(ctx context.Context, id uuid.UUID) (GetPropertyInfoRow, error) {
	row := q.db.QueryRow(ctx, getPropertyInfo, id)
	var i GetPropertyInfoRow
	err := row.Scan(
		&i.ID,
		&i.PropertyType,
		&i.Images,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Address,
		&i.City,
		&i.State,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.SquareFeet,
		&i.CreatedAt,
		&i.Agent,
	)
	return i, err
}
